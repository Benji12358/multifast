


module velocity_analyzer

    use mesh
    use boundaries
    use irregular_derivative_coefficients
    use schemes_interface
    use DNS_settings

    use decomp_2d
    use mpi

    implicit none

contains

    subroutine perform_divergence(div_z, q3_z, q2_y, q1_x, divy_mean)
        use poisson_interface
        use numerical_methods_settings
        use snapshot_writer
        use mpi
        use workspace_view
        implicit none
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)    :: q3_z
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)    :: q2_y
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)    :: q1_x

        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))              :: div1_x
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(out) :: div_z

        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))              :: div3_z, div2_z, div1_z, div_z2

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))   :: div2_y, div1_y
        real*8      :: divy_sum
        real*8, optional :: divy_mean

        integer k,j,i, mpi_err
        integer,save    :: nb=1
        !!!$    integer :: nb_taches
        !!!$    common/nb_total_threads/nb_taches


        ! X orientation ---------------------------------------------------------
        div1_x=0.d0
        !do k=1,n3m
        do k=xstart(3), min(n3m, xend(3))

            !do j=1,n2m
            do j=xstart(2), min(n2m, xend(2))

                call D1s(q1_x(:,j,k), div1_x(:,j,k), n1, dx1, .false., POISSON_VEL_BC1)

            enddo
        enddo

        ! Y orientation ---------------------------------------------------------

        div2_y=0.d0
        !do k=1,n3m
        do k=ystart(3), min(n3m, yend(3))
            !do i=1,n1m
            do i=ystart(1), min(n1m, yend(1))



                if (use_generic_poisson) then
                    call D1s_ExpCtr_O0Fp5_MULT(q2_y(i,:,k), div2_y(i,:,k), n2, dx2, .false., POISSON_VEL_BC2, Yc_to_YcTr_for_D1)

                else    ! ONLY FOR CHANNEL FLOWS
                    div2_y(i,1,k)=(q2_y(i,2,k) - q2_y(i,1,k))*Yc_to_YcTr_for_D1(1)/dx2
                    div2_y(i,n2m,k)=(q2_y(i,n2,k) - q2_y(i,n2m,k))*Yc_to_YcTr_for_D1(n2m)/dx2
                    call D1s_Tamm_MULT(q2_y(i,2:n2m,k), div2_y(i,2:n2m-1,k), n2m-1, dx2, .false., Dirichlet, Yc_to_YcTr_for_D1(2:n2m-1))
                end if

            enddo
        enddo

        ! Z orientation ---------------------------------------------------------

        div3_z=0.d0
        !do j = 1, n2m
        do j = zstart(2), min(n2m, zend(2))

            !do i=1,n1m
            do i=zstart(1), min(n1m, zend(1))
                call D1s(q3_z(i,j,:), div3_z(i,j,:), n3, dx3, .false., POISSON_VEL_BC3)
            enddo
        enddo


        call transpose_x_to_y(div1_x, div1_y)
        call transpose_y_to_z(div1_y, div1_z)

        call transpose_y_to_z(div2_y, div2_z)

        div_z=div1_z+div2_z+div3_z


        if (present(divy_mean)) then

            divy_mean=0.d0
            divy_sum=sum(div2_z)



            call MPI_ALLREDUCE (divy_sum, divy_mean, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            divy_mean=divy_mean/((n1-1)*(n2-1)*(n3-1))

        endif

        return

        contains


            subroutine print_div_debug

                implicit none

                div_z2=div_z

                if (nrank==0) write(*,*) "PERFORM DIVERGENCE **************************"
                if (nrank==0) write(*,*)'DIV2 mean', divy_mean
                write(*,*)'nrank', nrank, 'DIV2 mean loc', divy_sum
                if (nrank==0) write(*,*) "DIV X1"
                call MPI_BARRIER(MPI_COMM_WORLD, mpi_err)
                call poisson_execute(div1_z)

                if (nrank==0) write(*,*) "DIV X2"
                write(*,*)'nrank', nrank, sum(abs(q2_y(:,1,:))), sum(abs(q2_y(:,n2,:)))
                call MPI_BARRIER(MPI_COMM_WORLD, mpi_err)
                call poisson_execute(div2_z)

                if (nrank==0) write(*,*) "DIV X3"
                call MPI_BARRIER(MPI_COMM_WORLD, mpi_err)
                call poisson_execute(div3_z)

                if (nrank==0) write(*,*) "DIV TOT"
                call MPI_BARRIER(MPI_COMM_WORLD, mpi_err)
                call poisson_execute(div_z2)
                if (nrank==0) write(*,*) "*********************************************"

                if (nrank==0) write(*,*)

            end subroutine

    end subroutine

    subroutine check_sum(cs1, cs2, cs3, cs4)
        use physical_fields
        use mpi
        implicit none
        real*8  :: cs1_loc, cs2_loc, cs3_loc
        real*8  :: cs1, cs2, cs3, cs4
        integer k,j,i, mpi_err

        cs1_loc=0.d0
        cs2_loc=0.d0
        cs3_loc=0.d0


        do k=xstart(3), min(n3m, xend(3))
            do j=xstart(2), min(n2m, xend(2))
                do i=1, n1m
                    cs1_loc=cs1_loc+abs(q1_x(i,j,k))
                    cs2_loc=cs2_loc+abs(q2_x(i,j,k))
                    cs3_loc=cs3_loc+abs(q3_x(i,j,k))
                enddo
            enddo
        enddo

        call MPI_ALLREDUCE (cs1_loc, cs1, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (cs2_loc, cs2, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (cs3_loc, cs3, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        cs1=cs1/(n1m*n2m*n3m)
        cs2=cs2/(n1m*n2m*n3m)
        cs3=cs3/(n1m*n2m*n3m)

    end subroutine check_sum

    subroutine perform_gobal_divergence(div1, div2, q3_z, q2_y, q1_x)
        use numerical_methods_settings
        use mpi
        implicit none
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)    :: q3_z
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)    :: q2_y
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)    :: q1_x
        integer :: mpi_err

        real*8 :: div1, div1_loc
        real*8 :: div2, div2_loc

        integer k,j,i

        ! X orientation ---------------------------------------------------------
        div1_loc=0.d0
        !do k=1,n3m
        do k=xstart(3), min(n3m, xend(3))
            do j=xstart(2), min(n2m, xend(2))
                div1_loc=div1_loc+q1_x(n1,j,k)-q1_x(1,j,k)
            enddo
        enddo

        call MPI_ALLREDUCE (div1_loc, div1, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        ! Y orientation ---------------------------------------------------------

        !do k=1,n3m
        div2_loc=0.d0
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                div2_loc=div2_loc+q2_y(i,n2,k)-q2_y(i,1,k)
            enddo
        enddo
        call MPI_ALLREDUCE (div2_loc, div2, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        return

    end subroutine


    subroutine perform_velocity_at_center(q3_z, q2_y, q1_x, uc_z, vc_y, wc_x)
        implicit none

        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)    :: q3_z
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)    :: q2_y
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)    :: q1_x

        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))      :: wc_x, vc_x, uc_x
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))      :: uc_y, vc_y, wc_y
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))      :: uc_z, vc_z, wc_z

        integer k, j, i, mpi_err

        do k=xstart(3), min(n3m, xend(3))
            do j=xstart(2), min(n2m, xend(2))
                call D0s(q1_x(:,j,k), wc_x(:,j,k), n1, 0.d0, .false., NS_DEF_BC1)
            end do
        end do


        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                call D0s(q2_y(i,:,k), vc_y(i,:,k), n2, 0.d0, .false., NS_DEF_BC2)
            end do
        end do

        do i=zstart(1), min(n1m, zend(1))
            do j=zstart(2), min(n2m, zend(2))
                call D0s(q3_z(i,j,:), uc_z(i,j,:), n3, 0.d0, .false., NS_DEF_BC3)
            end do
        end do

    end subroutine perform_velocity_at_center

    subroutine perform_kinetic(q3_z, q2_y, q1_x, flow_rate, kin_energy, enstrophy, streamwise)

        use physical_fields, only:q3_y
        implicit none

        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)    :: q3_z
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)    :: q2_y
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)    :: q1_x
        real*8, intent(out)                     :: kin_energy(3), enstrophy, flow_rate
        integer, intent(in)             :: streamwise

        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))      :: wc_x, vc_x, uc_x
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))      :: uc_y, vc_y, wc_y
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))      :: uc_z, vc_z, wc_z

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))      :: vortX_y, vortY_y, vortZ_y


        integer k, j, i, mpi_err
        real*8  :: cflmax_glob=0.d0, kin_energy_glob(3)=0.d0, enstrophy_glob=0.d0, flow_rate_glob=0.d0

        call perform_velocity_at_center(q3_z, q2_y, q1_x, uc_z, vc_y, wc_x)

        call transpose_x_to_y(wc_x, wc_y)
        call transpose_z_to_y(uc_z, uc_y)

        call perform_vorticity

        kin_energy=0.d0
        enstrophy=0.d0
        flow_rate=0.d0

        do k=ystart(3), min(n3m, yend(3))
            !do i=1,n1m
            do j=1, n2m
                do i=ystart(1), min(n1m, yend(1))

                    if (streamwise==1) flow_rate= flow_rate+(wc_y(i,j,k)) * cell_size_Y(j) * dx1 * dx3
                    if (streamwise==3) flow_rate= flow_rate+(uc_y(i,j,k)) * cell_size_Y(j) * dx1 * dx3
                    kin_energy(1)= kin_energy(1)+(wc_y(i,j,k)**2) * cell_size_Y(j) * dx1 * dx3
                    kin_energy(2)= kin_energy(2)+(vc_y(i,j,k)**2) * cell_size_Y(j) * dx1 * dx3
                    kin_energy(3)= kin_energy(3)+(uc_y(i,j,k)**2) * cell_size_Y(j) * dx1 * dx3
                    enstrophy= enstrophy+(vortX_y(i,j,k)**2 + vortY_y(i,j,k)**2 + vortZ_y(i,j,k)**2) * cell_size_Y(j) * dx1 *dx3
                enddo
            enddo
        enddo

        call MPI_ALLREDUCE (flow_rate, flow_rate_glob, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (kin_energy(1), kin_energy_glob(1), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (kin_energy(2), kin_energy_glob(2), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (kin_energy(3), kin_energy_glob(3), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        call MPI_ALLREDUCE (enstrophy, enstrophy_glob, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        kin_energy=kin_energy_glob/(2.d0*L1*L3)
        enstrophy=enstrophy_glob/(2.d0*L1*L3)
        flow_rate=flow_rate_glob/(2.d0*L1*L3)

        return

    contains





        subroutine perform_vorticity()
            use physical_fields
            implicit none

            real*8      :: al_down, al_up
            real*8, dimension(3)    :: a_down, a_up
            integer                         :: i, j, k

            real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))      :: vortX_x, vortY_x
            real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))      :: vortY_z, vortZ_z




            call transpose_y_to_z(vc_y, vc_z)
            call transpose_y_to_z(wc_y, wc_z)

            call transpose_y_to_x(vc_y, vc_x)
            call transpose_y_to_x(uc_y, uc_x)

            ! Calculation of the coefficients of the schemes used at the walls...
            al_down=(Yc(2)-Yc(1))/(Yc(1)-y(1))

            a_down(1)=-al_down/(al_down+1)
            a_down(2)=(al_down-1)/al_down
            a_down(3)=1/(al_down**2+al_down)

            a_down=a_down/(Yc(1)-y(1))

            al_up=(y(n2)-Yc(n2m))/(Yc(n2m)-Yc(n2m-1))

            a_up(1)=-al_up/(al_up+1)
            a_up(2)=(al_up-1)/al_up
            a_up(3)=1/(al_up**2+al_up)

            a_up=a_up/(Yc(n2m)-Yc(n2m-1))

            ! Calcul de la composante selon x
            do k=xstart(3), min(n3m, xend(3))
                do j=xstart(2), min(n2m, xend(2))
                    call D1c(vc_x(:,j,k), vortX_x(:,j,k), n1, dx1, .true., NS_DEF_BC1)
                end do

            end do

            call transpose_x_to_y(vortX_x, vortX_y)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    vortX_y(i,1,k)=vortX_y(i,1,k) - (a_down(1)*q1_wall20(i,k) + a_down(2)*wc_y(i,1,k)+ a_down(3)*wc_y(i,2,k))
                    vortX_y(i,n2m,k)=vortX_y(i,n2m,k) - (a_up(1)*wc_y(i,n2m-1,k) + a_up(2)*wc_y(i,n2m,k)+ a_up(3)*q1_wall21(i,k))

                    call D1c_MULT_ACC(wc_y(i,:,k), vortX_y(i,:,k), n2, -dx2, .true., NS_DEF_BC2, Yc_to_YcTr_for_D1(:))

                end do
            end do








            ! Calcul de la composante selon y
            do k=xstart(3), min(n3m, xend(3))
                do j=xstart(2), min(n2m, xend(2))
                    call D1c(uc_x(:,j,k), vortY_x(:,j,k), n1, -dx1, .true., NS_DEF_BC1)
                end do
            end do

            call transpose_x_to_y(vortY_x, vortY_y)
            call transpose_y_to_z(vortY_y, vortY_z)

            do i=zstart(1), min(n1m, zend(1))
                do j=zstart(2), min(n2m, zend(2))
                    call D1c_ACC(wc_z(i,j,:), vortY_z(i,j,:), n3, dx3, .true., NS_DEF_BC3)
                end do

            end do

            call transpose_z_to_y(vortY_z, vortY_y)






            ! Calcul de la composante selon z
            do i=zstart(1), min(n1m, zend(1))
                do j=zstart(2), min(n2m, zend(2))
                    call D1c(vc_z(i,j,:), vortZ_z(i,j,:), n3, -dx3, .true., NS_DEF_BC3)
                end do
            end do

            call transpose_z_to_y(vortZ_z, vortZ_y)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))
                    vortZ_y(i,1,k)=vortZ_y(i,1,k) + (a_down(1)*q3_wall20(i,k) + a_down(2)*uc_y(i,1,k)+ a_down(3)*uc_y(i,2,k))
                    vortZ_y(i,n2m,k)=vortZ_y(i,n2m,k) + (a_up(1)*uc_y(i,n2m-1,k) + a_up(2)*uc_y(i,n2m,k)+ a_up(3)*q3_wall21(i,k))
                    call D1c_MULT_ACC(uc_y(i,:,k), vortZ_y(i,:,k), n2, dx2, .true., NS_DEF_BC2, Yc_to_YcTr_for_D1(:))
                end do

            end do

            !call assemble_global_y_all(vortX_y, vortX_3D, n1, n2, n3)
            !call assemble_global_y_all(vortY_y,vortY_3D,n1,n2,n3)
            !call assemble_global_y_all(vortZ_y, vortZ_3D, n1, n2, n3)

        end subroutine perform_vorticity

    end subroutine

    subroutine perform_stability(q3_z, q2_y, q1_x, cflmax, div_max, div_diff, div_mean)

        use physical_fields, only:q3_y
        implicit none

        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)    :: q3_z
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)    :: q2_y
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)    :: q1_x
        real*8, intent(out)                     :: cflmax, div_max, div_diff


        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))      :: wc_x, vc_x, uc_x
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))      :: uc_y, vc_y, wc_y
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))      :: uc_z, vc_z, wc_z

        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)) :: div_z
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)) :: div_x


        real*8                  :: cfl, div_min, div_sum, div_mean

        integer k, j, i, mpi_err
        real*8  :: div_max_glob=0.d0, div_min_glob, cflmax_glob=0.d0, kin_energy_glob(3)=0.d0, enstrophy_glob=0.d0

        call perform_velocity_at_center(q3_z, q2_y, q1_x, uc_z, vc_y, wc_x)

        cflmax=0.d0

        do k=ystart(3), min(n3m, yend(3))
            !do i=1,n1m
            do j=1, n2m
                do i=ystart(1), min(n1m, yend(1))
                    cfl=    abs(uc_y(i,j,k))/ dx3   +   &
                    abs(vc_y(i,j,k))/cell_size_Y(j)    +   &
                    abs(wc_y(i,j,k))/ dx1
                    cflmax=max(cfl, cflmax)
                enddo
            enddo
        enddo

        call MPI_ALLREDUCE (cflmax, cflmax_glob, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)

        cflmax=cflmax_glob*dt



        div_max=-100000.d0
        div_min=100000.d0
        div_sum=0.d0

        div_x=0.d0

        call perform_divergence(div_z, q3_z, q2_y, q1_x)

        do k=1, n3m
            do j=zstart(2), min(n2m, zend(2))
                do i=zstart(1), min(n1m, zend(1))
                    div_max=max(div_max, div_z(i,j,k))
                    div_min=min(div_min, div_z(i,j,k))
                    div_sum=div_sum+div_z(i,j,k)
                end do
            end do
        end do

        write(*,*)'div_min', div_min
        write(*,*)'div_max', div_max

        call MPI_ALLREDUCE (div_max, div_max_glob, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (div_min, div_min_glob, 1, MPI_DOUBLE_PRECISION , MPI_MIN , MPI_COMM_WORLD , mpi_err)
        call MPI_ALLREDUCE (div_sum, div_mean, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        if (abs(div_max_glob)>abs(div_min_glob)) then
            div_max=div_max_glob
        else
            div_max=div_min_glob
        endif


        div_mean=div_mean/(n1m*n2m*n3m)
        div_diff=div_max_glob-div_min_glob

        if (nrank==0) write(*,*)'div_min_glob', div_min_glob
        if (nrank==0) write(*,*)'div_max_glob', div_max_glob

        return

    end subroutine

    subroutine perform_kinetic_IBM(q3c_z, q2c_y, q1c_x, flow_rate, k1, k2, k3)
        implicit none
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)      :: q1c_x
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)), intent(in)      :: q2c_y
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3)), intent(in)      :: q3c_z


        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))      :: q2c_x, q3c_x
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3))      :: q1c_y, q3c_y
        real*8, dimension(zstart(1):zend(1), zstart(2):zend(2), zstart(3):zend(3))      :: q1c_z, q2c_z

        real*8, dimension(xsize(1))                                                     :: flow_rate, k1,k2,k3

        real*8  :: debit, debit_loc, k1_loc, k2_loc, k3_loc
        integer k,i,j, mpi_err


        call transpose_z_to_y(q3c_z, q3c_y)
        call transpose_y_to_x(q3c_y, q3c_x)

        call transpose_y_to_x(q2c_y, q2c_x)

        do i=xstart(1), min(n1m, xend(1))

            ! Flow rate calculation
            debit_loc=0.d0
            k1_loc=0.d0
            k2_loc=0.d0
            k3_loc=0.d0


            do k=xstart(3), min(n3m, xend(3))
                do j=xstart(2), min(n2m, xend(2))
                    debit_loc=debit_loc +q1c_x(i,j,k) * (Y(j+1)-Y(j))*dx3
                    k1_loc=k1_loc       +(q1c_x(i,j,k)**2) * (Y(j+1)-Y(j)) * dx3
                    k2_loc=k2_loc       +(q2c_x(i,j,k)**2) * (Y(j+1)-Y(j)) * dx3
                    k3_loc=k3_loc       +(q3c_x(i,j,k)**2) * (Y(j+1)-Y(j)) * dx3
                enddo
            enddo

            call MPI_ALLREDUCE (debit_loc, flow_rate(i), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (k1_loc, k1(i), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (k2_loc, k2(i), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (k3_loc, k3(i), 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)

        enddo

        flow_rate=flow_rate/(L2*L3)
        k1=k1/(L2*L3)
        k2=k2/(L2*L3)
        k3=k3/(L2*L3)

    end subroutine perform_kinetic_IBM

    subroutine perform_maxvel_IBM(q3_x, q2_x, q1_x, dp_x, q1_max, q2_max, q3_max, pr_max, q1_min, q2_min, q3_min, pr_min)
        implicit none
        real*8, dimension(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3)), intent(in)      :: q1_x, q2_x, q3_x, dp_x


        real*8, dimension(xsize(1))                                                     :: q1_max, q2_max, q3_max, pr_max
        real*8, dimension(xsize(1))                                                     :: q1_min, q2_min, q3_min, pr_min

        real*8  :: debit, debit_loc, q1_max_loc, q2_max_loc, q3_max_loc, q1_min_loc, q2_min_loc, q3_min_loc, pr_min_loc, pr_max_loc
        integer k,i,j, mpi_err


        do i=xstart(1), min(n1m, xend(1))

            ! Flow rate calculation
            debit_loc=0.d0
            q1_max_loc=-10000.d0
            q2_max_loc=-10000.d0
            q3_max_loc=-10000.d0
            pr_max_loc=-10000.d0
            q1_min_loc=10000.d0
            q2_min_loc=10000.d0
            q3_min_loc=10000.d0
            pr_min_loc=10000.d0


            do k=xstart(3), min(n3m, xend(3))
                do j=xstart(2), min(n2m, xend(2))

                    q1_max_loc=max(q1_max_loc, q1_x(i,j,k))
                    q2_max_loc=max(q2_max_loc, q2_x(i,j,k))
                    q3_max_loc=max(q3_max_loc, q3_x(i,j,k))
                    pr_max_loc=max(pr_max_loc, dp_x(i,j,k))

                    q1_min_loc=min(q1_min_loc, q1_x(i,j,k))
                    q2_min_loc=min(q2_min_loc, q2_x(i,j,k))
                    q3_min_loc=min(q3_min_loc, q3_x(i,j,k))
                    pr_min_loc=min(pr_min_loc, dp_x(i,j,k))

                enddo
            enddo

            call MPI_ALLREDUCE (q1_max_loc, q1_max(i), 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (q2_max_loc, q2_max(i), 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (q3_max_loc, q3_max(i), 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (pr_max_loc, pr_max(i), 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)

            call MPI_ALLREDUCE (q1_min_loc, q1_min(i), 1, MPI_DOUBLE_PRECISION , MPI_MIN , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (q2_min_loc, q2_min(i), 1, MPI_DOUBLE_PRECISION , MPI_MIN , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (q3_min_loc, q3_min(i), 1, MPI_DOUBLE_PRECISION , MPI_MIN , MPI_COMM_WORLD , mpi_err)
            call MPI_ALLREDUCE (pr_min_loc, pr_min(i), 1, MPI_DOUBLE_PRECISION , MPI_MIN , MPI_COMM_WORLD , mpi_err)

        enddo

    end subroutine perform_maxvel_IBM

end module velocity_analyzer

