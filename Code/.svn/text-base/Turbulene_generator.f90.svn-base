module Turbulene_generator

    use physical_fields
    use snapshot_writer
    use DNS_settings

    implicit none

contains
    !  *************** subrout init_physical_fields **********************

    !   initial velocity Poiseuille profile
    !   plus random disturbance

    subroutine init_channel_flow(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: disturbance_intensity_at_j


        real*8, dimension (n2)    :: cac

        real*8, dimension(n2) :: v30
        real*8, dimension(n2)   :: v1m, v2m, v3m, q1m, q2m
        integer j,k,i,l, mpi_err
        real*8 vol,velocity_poisseuille,velocity_Z_disturbance,velocity_Y_disturbance,velocity_X_disturbance
        integer, parameter  :: ndv=3
        real*8 vmax(ndv)

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8  :: glob_value

        integer :: writer_proc=0
        integer :: log_file_id=20
        character(200)  :: field_generator_path
        integer :: meanXZ_perturbation_file_id=21, zone_id, var_id
        integer, dimension(n2m) :: j_array

        real*8  :: ycenter

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************

        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        vol=dfloat(n1m*n2m*n3m)*2.d0


        cac(1)  =(y(2)-y(1))*dx2
        do j=2,n2m
            cac(j)=(y(j+1)-y(j-1))*dx2*0.5d0
        enddo
        cac(n2) =(y(n2)-y(n2m))*dx2


        !  v30(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        do j=1,n2m
            v1m(j)=0.d0
            v2m(j)=0.d0
            v3m(j)=0.d0

            disturbance_intensity_at_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) disturbance_intensity_at_j=disturbance_intensity/5.

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=disturbance_intensity_at_j
                    q2_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_u(i,j,k))

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        velocity_poisseuille    =0.d0
        velocity_Z_disturbance  =0.d0
        velocity_Y_disturbance  =0.d0
        velocity_X_disturbance  =0.d0

        do j=1,n2m

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            v30(j)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j)
                    q3_y(i,j,k)=q3_y(i,j,k) + v30(j)        ! Poiseuille + disturbance

                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)

                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j)


                    velocity_poisseuille    = velocity_poisseuille      +   v30(j)*cell_size_Y(j)/dx2
                    velocity_Z_disturbance  = velocity_Z_disturbance    +   q1_y(i,j,k)*cell_size_Y(j)/dx2
                    velocity_Y_disturbance  = velocity_Y_disturbance    +   (q2_y(i,j,k)*cac(j) + q2_y(i,j+1,k)*cac(j+1) )*0.5d0
                    velocity_X_disturbance  = velocity_X_disturbance    +   q3_y(i,j,k)*cell_size_Y(j)/dx2

                enddo
            enddo
        enddo

        call MPI_ALLREDUCE (velocity_poisseuille, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_poisseuille=glob_value/vol

        call MPI_ALLREDUCE (velocity_Z_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_Z_disturbance=glob_value/vol

        call MPI_ALLREDUCE (velocity_Y_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_Y_disturbance=glob_value/vol

        call MPI_ALLREDUCE (velocity_X_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_X_disturbance=glob_value/vol


        !Impermeability conditions
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                q2_y(i,1,k)=0.d0
                q2_y(i,n2,k)=0.d0
            enddo
        enddo

        !   q1m(j): mean along (X, Z) of transverse disturbance    (=0)
        !   q2m(j): mean along (X, Z) of normal disturbance        (=0)
        do j=1,n2m
            q1m(j)=0.d0
            q2m(j)=0.d0

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))
                    q1m(j)=q1m(j)+q1_y(i,j,k)
                    q2m(j)=q2m(j)+q2_y(i,j,k)
                enddo
            enddo

            call MPI_ALLREDUCE (q1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            q1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (q2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            q2m(j)=glob_value/dfloat(n1m*n3m)
        enddo


        do j=2,n2m

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))
                    q2_y(i,j,k)=q2_y(i,j,k)-q2m(j)
                enddo
            enddo

        enddo


        do j=1,n2m
            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q1_y(i,j,k)=q1_y(i,j,k)-q1m(j)

                enddo
            enddo

        enddo

        vmax(1)=MAXVAL(abs(q1_y))
        vmax(2)=MAXVAL(abs(q2_y))
        vmax(3)=MAXVAL(abs(q3_y))


        call MPI_ALLREDUCE (vmax(1), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(1)=glob_value


        call MPI_ALLREDUCE (vmax(2), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(2)=glob_value


        call MPI_ALLREDUCE (vmax(3), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(3)=glob_value



        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)


        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
115     format(' Bulk velocity of the Poiseuille profile velocity_poisseuille=',e10.3)
116     format(' velocity_X_disturbance=',e10.3,2x,'velocity_Y_disturbance=',e10.3,2x,'velocity_Z_disturbance=',e10.3)
117     format(' Maximum Velocity w max=',e11.4,2x, 'v max=',e11.4,2x,'u max=',e11.4)

        if (nrank==writer_proc) then

            field_generator_path=trim(log_path)//"Fields_generator/"

            open(log_file_id,file=trim(field_generator_path)//'overview.out')

            write(log_file_id,115) velocity_poisseuille
            write(log_file_id,116) velocity_X_disturbance,velocity_Y_disturbance,velocity_Z_disturbance
            write(log_file_id,117) (vmax(l),l=1,3)
            write(log_file_id,*)'Mean along x1 & x3 of the initial perturbation'

            write(log_file_id,*)'j, q1m(j), q2m(j), v3m(j)'
            do j=1,n2m
                write(log_file_id,615)j,q1m(j),q2m(j),v3m(j)
            enddo

615         format(2x,i3,2x,3e12.4)
            close(log_file_id)

        end if

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        return
    end subroutine

    subroutine init_channel_flow2(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: disturbance_intensity_at_j


        real*8, dimension (n2)    :: cac

        real*8, dimension(n2) :: ustream
        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err
        real*8 vol,velocity_poisseuille,velocity_Z_disturbance,velocity_Y_disturbance,velocity_X_disturbance
        integer, parameter  :: ndv=3
        real*8 vmax(ndv)

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8  :: glob_value

        integer :: writer_proc=0
        integer :: log_file_id=20
        character(200)  :: field_generator_path
        integer :: meanXZ_perturbation_file_id=21, zone_id, var_id
        integer, dimension(n2m) :: j_array

        real*8  :: ycenter

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************

        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        vol=dfloat(n1m*n2m*n3m)*2.d0


        cac(1)  =(y(2)-y(1))*dx2
        do j=2,n2m
            cac(j)=(y(j+1)-y(j-1))*dx2*0.5d0
        enddo
        cac(n2) =(y(n2)-y(n2m))*dx2


        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        do j=1,n2m
            v1m(j)=0.d0
            v2m(j)=0.d0
            v3m(j)=0.d0

            disturbance_intensity_at_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) disturbance_intensity_at_j=disturbance_intensity/5.

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_u(i,j,k))
                    q2_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=disturbance_intensity_at_j

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        velocity_poisseuille    =0.d0
        velocity_Z_disturbance  =0.d0
        velocity_Y_disturbance  =0.d0
        velocity_X_disturbance  =0.d0

        do j=1,n2m

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            ustream(j)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j)
                    q1_y(i,j,k)=q1_y(i,j,k) + ustream(j)        ! Poiseuille + disturbance

                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j)


                    velocity_poisseuille    = velocity_poisseuille      +   ustream(j)*cell_size_Y(j)/dx2
                    velocity_Z_disturbance  = velocity_Z_disturbance    +   q1_y(i,j,k)*cell_size_Y(j)/dx2
                    velocity_Y_disturbance  = velocity_Y_disturbance    +   (q2_y(i,j,k)*cac(j) + q2_y(i,j+1,k)*cac(j+1) )*0.5d0
                    velocity_X_disturbance  = velocity_X_disturbance    +   q3_y(i,j,k)*cell_size_Y(j)/dx2

                enddo
            enddo
        enddo

        call MPI_ALLREDUCE (velocity_poisseuille, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_poisseuille=glob_value/vol

        call MPI_ALLREDUCE (velocity_Z_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_Z_disturbance=glob_value/vol

        call MPI_ALLREDUCE (velocity_Y_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_Y_disturbance=glob_value/vol

        call MPI_ALLREDUCE (velocity_X_disturbance, glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
        velocity_X_disturbance=glob_value/vol


        !Impermeability conditions
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                q2_y(i,1,k)=0.d0
                q2_y(i,n2,k)=0.d0
            enddo
        enddo


        vmax(1)=MAXVAL(abs(q1_y))
        vmax(2)=MAXVAL(abs(q2_y))
        vmax(3)=MAXVAL(abs(q3_y))


        call MPI_ALLREDUCE (vmax(1), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(1)=glob_value


        call MPI_ALLREDUCE (vmax(2), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(2)=glob_value


        call MPI_ALLREDUCE (vmax(3), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , mpi_err)
        vmax(3)=glob_value



        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)


        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
115     format(' Bulk velocity of the Poiseuille profile velocity_poisseuille=',e10.3)
116     format(' velocity_X_disturbance=',e10.3,2x,'velocity_Y_disturbance=',e10.3,2x,'velocity_Z_disturbance=',e10.3)
117     format(' Maximum Velocity w max=',e11.4,2x, 'v max=',e11.4,2x,'u max=',e11.4)

        if (nrank==writer_proc) then

            field_generator_path=trim(log_path)//"Fields_generator/"

            open(log_file_id,file=trim(field_generator_path)//'overview.out')

            write(log_file_id,115) velocity_poisseuille
            write(log_file_id,116) velocity_X_disturbance,velocity_Y_disturbance,velocity_Z_disturbance
            write(log_file_id,117) (vmax(l),l=1,3)
            write(log_file_id,*)'Mean along x1 & x3 of the initial perturbation'

            write(log_file_id,*)'j, v1m(j), v2m(j), v3m(j)'
            do j=1,n2m
                write(log_file_id,615)j,v1m(j),v2m(j),v3m(j)
            enddo

615         format(2x,i3,2x,3e12.4)
            close(log_file_id)

        end if

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        return
    end subroutine

    subroutine init_channel_flow3(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: disturbance_intensity_at_j


        real*8, dimension (n2)    :: cac

        real*8, dimension(n2) :: v30
        real*8, dimension(n2)   :: v1m, v2m, v3m, q1m, q2m
        integer j,k,i,l, mpi_err
        real*8 vol,velocity_poisseuille,velocity_Z_disturbance,velocity_Y_disturbance,velocity_X_disturbance
        integer, parameter  :: ndv=3

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8  :: glob_value

        integer :: writer_proc=0
        integer :: log_file_id=20
        character(200)  :: field_generator_path
        integer :: meanXZ_perturbation_file_id=21, zone_id, var_id
        integer, dimension(n2m) :: j_array

        real*8  :: ycenter

        write(*,*)"init_channel_flow version 3"

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************

        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        vol=dfloat(n1m*n2m*n3m)*2.d0


        cac(1)  =(y(2)-y(1))*dx2
        do j=2,n2m
            cac(j)=(y(j+1)-y(j-1))*dx2*0.5d0
        enddo
        cac(n2) =(y(n2)-y(n2m))*dx2


        !  v30(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        do j=1,n2m
            v1m(j)=0.d0
            v2m(j)=0.d0
            v3m(j)=0.d0

            disturbance_intensity_at_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) disturbance_intensity_at_j=disturbance_intensity/5.

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=disturbance_intensity_at_j
                    q2_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_u(i,j,k))

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        do j=1,n2m

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            v30(j)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j)
                    q3_y(i,j,k)=q3_y(i,j,k) + v30(j)        ! Poiseuille + disturbance

                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)

                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j)

                enddo
            enddo
        enddo

        !Impermeability conditions
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                q2_y(i,1,k)=0.d0
                q2_y(i,n2,k)=0.d0
            enddo
        enddo

        !   q1m(j): mean along (X, Z) of transverse disturbance    (=0)
        !   q2m(j): mean along (X, Z) of normal disturbance        (=0)
        do j=1,n2m
            q1m(j)=0.d0
            q2m(j)=0.d0

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))
                    q1m(j)=q1m(j)+q1_y(i,j,k)
                    q2m(j)=q2m(j)+q2_y(i,j,k)
                enddo
            enddo

            call MPI_ALLREDUCE (q1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            q1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (q2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            q2m(j)=glob_value/dfloat(n1m*n3m)
        enddo


        do j=2,n2m

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))
                    q2_y(i,j,k)=q2_y(i,j,k)-q2m(j)
                enddo
            enddo

        enddo


        do j=1,n2m
            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q1_y(i,j,k)=q1_y(i,j,k)-q1m(j)

                enddo
            enddo

        enddo



        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        return
    end subroutine

    subroutine init_channel_flow4(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: disturbance_intensity_at_j

        real*8, dimension(n2) :: ustream
        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8  :: glob_value

        real*8  :: ycenter

        write(*,*)"init_channel_flow version 4"

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        do j=1,n2m
            v1m(j)=0.d0
            v2m(j)=0.d0
            v3m(j)=0.d0

            disturbance_intensity_at_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) disturbance_intensity_at_j=disturbance_intensity/5.

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=disturbance_intensity_at_j
                    q2_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_u(i,j,k))

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        do j=1,n2m

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            ustream(j)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j) + ustream(j)        ! Poiseuille + disturbance
                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)
                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j)

                enddo
            enddo
        enddo

        !Impermeability conditions
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                q2_y(i,1,k)=0.d0
                q2_y(i,n2,k)=0.d0
            enddo
        enddo

        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        return
    end subroutine

    subroutine init_channel_flow5(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: disturbance_intensity_at_j

        real*8, dimension(n2) :: ustream
        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: ts
        real*8  :: glob_value

        real*8  :: ycenter

        write(*,*)"init_channel_flow version 5"

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        do j=1,n2m
            v1m(j)=0.d0
            v2m(j)=0.d0
            v3m(j)=0.d0

            disturbance_intensity_at_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) disturbance_intensity_at_j=disturbance_intensity/5.

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_u(i,j,k))
                    q2_y(i,j,k)=disturbance_intensity_at_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=disturbance_intensity_at_j

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        do j=1,n2m

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            ts(j,:)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), min(n3m, yend(3))
                do i=ystart(1), min(n1m, yend(1))

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j)
                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)
                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j) + ts(j,k)        ! Poiseuille + disturbance

                enddo
            enddo
        enddo

        !Impermeability conditions
        do k=ystart(3), min(n3m, yend(3))
            do i=ystart(1), min(n1m, yend(1))
                q2_y(i,1,k)=0.d0
                q2_y(i,n2,k)=0.d0
            enddo
        enddo

        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        return
    end subroutine

    subroutine init_channel_flow6(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use workspace_view
        use boundaries


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: modulation_j

        real*8, dimension(n2) :: ustream
        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err

        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2), ystart(3):yend(3)) :: rand_u, rand_v
        real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: ts
        real*8, dimension(xstart(2):xend(2), xstart(3):xend(3))     :: q2w_fluc, q3w_fluc
        real*8  :: glob_value

        real*8  :: ycenter

        write(*,*)"init_channel_flow version 5"

        call random_number(rand_u)
        call random_number(rand_v)

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
        pr_x(xstart(1):xend(1), xstart(2):xend(2), xstart(3):xend(3))=0.d0



        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer


        v1m=0.d0
        v2m=0.d0
        v3m=0.d0

        do j=1,n2

            modulation_j=disturbance_intensity
            if((1.d0-dabs(Yc(j))).lt.0.025) modulation_j=disturbance_intensity/5.

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=modulation_j*(-1.d0+2.d0*rand_u(i,j,k))
                    q2_y(i,j,k)=modulation_j*(-1.d0+2.d0*rand_v(i,j,k))
                    q3_y(i,j,k)=modulation_j

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo

        do j=1,n2

            if (mod(n2, 2)==0) then
                ycenter=Yc(n2/2)
            else
                ycenter=Y((n2-1)/2+1)
            end if

            ts(j,:)=(1.d0-((Yc(j)-ycenter)/(0.5d0*L2))**2)

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j)
                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)
                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j) + ts(j,k)        ! Poiseuille + disturbance

                enddo
            enddo
        enddo

        call transpose_y_to_z(q3_y, q3_z)
        call transpose_y_to_x(q1_y, q1_x)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        !Impermeability conditions ********************************************************

        ! X2 direction
        if ((BC2==FREESLIP).or.(BC2==NOSLIP)) then

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)
                    ! Modify only q2: q1 and q3 are not on the X2-wall
                    q2_y(i,1,k)=0.d0
                    q2_y(i,n2,k)=0.d0
                    ! No need to fill qi_wall20 and qi_wall21: not used in freeslip case and set to zero by apply_YBC
                    ! subroutines in noslip case
                enddo
            enddo

        end if

        ! ATTENTION
        ! X3 direction
        if ((BC3==FREESLIP).or.(BC3==NOSLIP)) then

            do j=zstart(2), zend(2)
                do i=zstart(1), zend(1)
                    ! Modify only q3: q1 and q2 are not on the X3-wall
                    q3_z(i,j,1) =0.d0
                    q3_z(i,j,n3)=0.d0
                    ! No need to fill qi_wall30 and qi_wall31: not used in freeslip case and set to zero by apply_ZBC
                    ! subroutines in noslip case
                enddo
            enddo

        end if

        ! X1 direction: NEVER FREE-SLIP or NOSLIP condition in this direction


        if (BC1==OPEN) then

            call random_number(q2w_fluc)
            call random_number(q3w_fluc)

            do k=xstart(3), xend(3)
                do j=xstart(2), xend(2)

                    if((1.d0-dabs(Yc(j))).lt.0.025) modulation_j=disturbance_intensity/5.

                    ! The subroutine apply_ZBC performs qi_wall10 from its initial value ==>
                    ! qi_wall10 must then be intialized
                    q1_wall10(j, k)=q1_x(1,j,k)
                    q2_wall10(j, k)=modulation_j*(-1.d0+2.d0*q2w_fluc(j,k))
                    q3_wall10(j, k)=modulation_j
                    ! q2 and q3 are not on this wall. q1_x at the wall will be performed by apply_ZBC from qi_wall10
                    ! and q1_x(n1-1,:,:)
                enddo
            enddo

        end if

        return
    end subroutine

    subroutine init_channel_flow8(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use inflow_settings
        use workspace_view
        use boundaries


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: modulation_j

        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err
        integer :: n1s, n1e, n2s, n2e, n3s, n3e

        real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: ts1
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2)) :: ts3
        real*8  :: glob_value

        real*8  :: yr, ycenter

        ! TEST INFLOW:
        integer :: k1, k2, j1, j2
        if (.true.) then
            k1=22
            k2=42
            j1=22
            j2=42
        endif
        if(.false.) then
            k1=1!22
            k2=n3!42
            j1=1!22
            j2=n2!42
        endif

        write(*,*)"init_channel_flow version 8"

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
        pr_x=0.d0


        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer

        n1s=ystart(1)
        n2s=ystart(2)
        n3s=ystart(3)

        n1e=min(yend(1), n1-1)
        n2e=min(yend(2), n2-1)
        n3e=min(yend(3), n3-1)

        call random_number(q1_y(n1s:n1e, n2s:n2e, n3s:n3e))
        call random_number(q2_y(n1s:n1e, n2s:n2e, n3s:n3e))
        call random_number(q3_y(n1s:n1e, n2s:n2e, n3s:n3e))

        v1m=0.d0
        v2m=0.d0
        v3m=0.d0

        do j=1,n2-1

            yr=abs(Yc(j)-L2/2.d0)
            modulation_j=disturbance_intensity*dexp(-0.2d0*yr**2)

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=q1_y(i,j,k)*modulation_j
                    q2_y(i,j,k)=q2_y(i,j,k)*modulation_j
                    q3_y(i,j,k)=q3_y(i,j,k)*modulation_j

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo


        ts1=0.d0
        ts3=0.d0

        if (flow_type==CONSTANT_FLOW) then
            if (streamwise==1)  ts1=uref
            if (streamwise==3)  ts3=uref
        end if

        if (flow_type==CHANNEL_FLOW) then
            if (streamwise==1) call perform_stream1(ts1, BC2, BC3)
            if (streamwise==3) call perform_stream3(ts3, BC1, BC2)
        end if

        do j=1,n2

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j) + ts3(i,j)
                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)
                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j) + ts1(j,k)        ! Poiseuille + disturbance

                enddo
            enddo
        enddo

        ! CLEAN FIELDS ***************************************************************
        if (yend(1)==n1) then
            do k = ystart(3), yend(3)
                do j = 1, n2
                    q1_y(n1,j,k)=0.d0
                    q2_y(n1,j,k)=0.d0
                    q3_y(n1,j,k)=0.d0
                    !if ((BC1==OPEN2).or.(BC1==UNBOUNDED).or.(BC1==UNBOUNDED)
                end do
            end do
        end if

        if (yend(3)==n3) then
            do j = 1, n2
                do i = ystart(1), yend(1)
                    q1_y(i,j,n3)=0.d0
                    q2_y(i,j,n3)=0.d0
                    q3_y(i,j,n3)=0.d0
                end do
            end do
        end if

        do k = ystart(3), yend(3)
            do i = ystart(1), yend(1)
                q1_y(i,n2,k)=0.d0
                q2_y(i,n2,k)=0.d0
                q3_y(i,n2,k)=0.d0
            end do
        end do

        call transpose_y_to_x(q3_y, q3_x)
        call transpose_y_to_z(q3_y, q3_z)

        call transpose_y_to_x(q1_y, q1_x)
        call transpose_y_to_z(q1_y, q1_z)

        call transpose_y_to_x(q2_y, q2_x)
        call transpose_y_to_z(q2_y, q2_z)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        !Impermeability conditions ********************************************************

        ! X1 direction
        if ((BC1==FREESLIP).or.(BC1==NOSLIP)) then

            q3_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q2_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_x(1, xstart(2):xend(2), xstart(3):xend(3))   =0.d0

            q3_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q2_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_x(n1, xstart(2):xend(2), xstart(3):xend(3))  =0.d0

        end if

        ! X2 direction
        if ((BC2==FREESLIP).or.(BC2==NOSLIP)) then

            q3_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q1_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_y(ystart(1):yend(1), 1, ystart(3):yend(3))   =0.d0

            q3_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q1_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_y(ystart(1):yend(1), n2, ystart(3):yend(3))  =0.d0

        end if

        ! ATTENTION
        ! X3 direction
        if ((BC3==FREESLIP).or.(BC3==NOSLIP)) then

            q3_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q2_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q1_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q3_z(zstart(1):zend(1), zstart(2):zend(2), 1) =0.d0

            q3_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q2_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q1_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q3_z(zstart(1):zend(1), zstart(2):zend(2), n3) =0.d0

        end if

        ! ATTENTION
        if ((BC1==OPEN).or.(BC1==OPEN2)) then

            call random_number(q2_wall10(xstart(2):xend(2), xstart(3):xend(3)))
            call random_number(q3_wall10(xstart(2):xend(2), xstart(3):xend(3)))

            do k=xstart(3), xend(3)
                do j=xstart(2), min(xend(2),n2-1)

                    yr=abs(Yc(j)-L2/2.d0)
                    modulation_j=disturbance_intensity*dexp(-0.2d0*yr**2)

                    if (inflow_mode==INFLOW_SQUARE) then

                        if ((k.ge.inflow_sq_k1).and.(k.lt.inflow_sq_k2).and.(j.ge.inflow_sq_j1).and.(j.lt.inflow_sq_j2)) then
                            q1_wall10(j, k)=inflow_int
                            q1_x(1,j,k)=q1_wall10(j, k)
                            q2_wall10(j, k)=0.d0
                            q3_wall10(j, k)=0.d0
                        else
                            q1_wall10(j, k)=q1_x(1,j,k)
                            q2_wall10(j, k)=q2_wall10(j, k)*modulation_j
                            q3_wall10(j, k)=q3_wall10(j, k)*modulation_j
                        endif

                    endif

                    if (inflow_mode==INFLOW_NONE) then

                        q1_wall10(j, k)=q1_x(1,j,k)
                        q2_wall10(j, k)=q2_wall10(j, k)*modulation_j
                        q3_wall10(j, k)=q3_wall10(j, k)*modulation_j

                    endif

                    q3_wall11(j, k) = q3_x(n1-1, j, k)
                    q2_wall11(j, k) = q2_x(n1-1, j, k)
                    q1_wall11(j, k) = q1_x(n1-1, j, k)
                    q1_x(n1, j, k)  = q1_wall11(j, k)

                enddo
            enddo

        end if

        !ATTENTION ATTENTION ATTENTION ATTENTION !!!!!!!! (PAS TROP VERIFIE)
        if (BC3==OPEN) then

            call random_number(q1_wall30(xstart(2):xend(2), xstart(3):xend(3)))
            call random_number(q2_wall30(xstart(2):xend(2), xstart(3):xend(3)))

            do j=zstart(2), zend(2)
                do i=zstart(1), zend(1)

                    yr=abs(Yc(j)-L2/2.d0)
                    modulation_j=disturbance_intensity*dexp(-0.2d0*yr**2)

                    q1_wall30(i,j)=q1_wall30(i,j)*modulation_j
                    q2_wall30(i,j)=q2_wall30(i,j)*modulation_j
                    q3_wall30(i,j)=q3_z(i,j,1)

                    q1_wall31(i,j)=q1_z(i,j,n3-1)
                    q2_wall31(i,j)=q2_z(i,j,n3-1)
                    q3_wall31(i,j)=q3_z(i,j,n3-1)
                    q3_z(i,j,n3)=q3_wall31(i,j)
                enddo
            enddo

        end if

        call create_snapshot(snapshot_path, "INITIALIZATION", q1_y, "W", 2)
        call create_snapshot(snapshot_path, "INITIALIZATION", q2_y, "V", 2)
        call create_snapshot(snapshot_path, "INITIALIZATION", q3_y, "U", 2)

        return


    contains
        subroutine perform_stream1(stream1, BC2, BC3)
            implicit none

            real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: stream1
            integer                                                 :: BC2, BC3

            real*8                                                  :: f2(n2), f3(n3), c2, c3
            integer                                                 :: j, k

            f3=1.d0

            if (BC2==NOSLIP) then


                do j=1,n2

                    if (mod(n2, 2)==0) then
                        c2=Yc(n2/2)
                    else
                        c2=Y((n2-1)/2+1)
                    end if

                    f2(j)=(1.d0-((Yc(j)-c2)/(0.5d0*L2))**2)

                enddo

                if (BC3==NOSLIP) then

                    do k=1,n3

                        if (mod(n3, 2)==0) then
                            c3=(n3/2-0.5d0)*dx3
                        else
                            c3=((n3-1)/2+1-0.5d0)*dx3
                        end if

                        f3(k)=(1.d0-(((k-0.5d0)*dx3-c3)/(0.5d0*L3))**2)

                    enddo

                end if

                do k = ystart(3),yend(3)
                    do j= ystart(2),yend(2)
                        stream1(j,k)=f2(j)*f3(k)
                    end do
                end do

            else
                stream1=0.d0
            end if

        end subroutine perform_stream1


        subroutine perform_stream3(stream3, BC1, BC2)
            implicit none

            real*8, dimension(ystart(1):yend(1), ystart(2):yend(2)) :: stream3
            integer                                                 :: BC1, BC2

            real*8                                                  :: f1(n1), f2(n2), c1, c2
            integer                                                 :: i, j

            f1=1.d0

            if (BC2==NOSLIP) then


                do j=1,n2

                    if (mod(n2, 2)==0) then
                        c2=Yc(n2/2)
                    else
                        c2=Y((n2-1)/2+1)
                    end if

                    f2(j)=(1.d0-((Yc(j)-c2)/(0.5d0*L2))**2)

                enddo

                if (BC1==NOSLIP) then

                    if (mod(n1, 2)==0) then
                        ! Zc=(i-0.5)*dx1
                        c1=(n1/2-0.5d0)*dx1
                    else
                        c1=((n1-1)/2+1-0.5d0)*dx1
                    end if

                    do i=1,n1
                        f1(i)=(1.d0-(((i-0.5d0)*dx1-c1)/(0.5d0*L1))**2)
                    enddo

                end if

                do j = ystart(2),yend(2)
                    do i= ystart(1),yend(1)
                        stream3(i,j)=f1(i)*f2(j)
                    end do
                end do

            else
                stream3=0.d0
            end if

        end subroutine perform_stream3

    end subroutine

    subroutine init_channel_flow9(disturbance_intensity) !!,y dummy argument

        use mesh
        use irregular_derivative_coefficients
        use mathematical_constants
        use DNS_settings
        use inflow_settings
        use workspace_view
        use boundaries


        use mpi
        use decomp_2d

        implicit none

        real*8, intent(in)  :: disturbance_intensity
        real*8              :: modulation_j

        real*8, dimension(n2)   :: v1m, v2m, v3m
        integer j,k,i,l, mpi_err
        integer :: n1s, n1e, n2s, n2e, n3s, n3e

        real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: ts1
        real*8, dimension(ystart(1):yend(1), ystart(2):yend(2)) :: ts3
        real*8  :: glob_value

        real*8  :: yr, ycenter

        ! TEST INFLOW:
        integer :: k1, k2, j1, j2
        if (.true.) then
            k1=22
            k2=42
            j1=22
            j2=42
        endif
        if(.false.) then
            k1=1!22
            k2=n3!42
            j1=1!22
            j2=n2!42
        endif

        write(*,*)"init_channel_flow version 8"

        ! **************************************************************************************
        ! Pressure field initialisation --------------------------------------------------------
        ! **************************************************************************************
        pr_x=0.d0


        ! **************************************************************************************
        ! Velocity field initialisation --------------------------------------------------------
        ! **************************************************************************************
        !  ustream(j): Poiseuille profile at the center of the cell
        !  v1m(j): Mean following X, Z of the Z component of the random perturbation
        !  v2m(j): Mean following X, Z of the Y component of the random perturbation
        !  v3m(j): Mean following X, Z of the X component of the random perturbation

        !        TO NOTE : The random number generator depends on the computer

        n1s=ystart(1)
        n2s=ystart(2)
        n3s=ystart(3)

        n1e=min(yend(1), n1-1)
        n2e=min(yend(2), n2-1)
        n3e=min(yend(3), n3-1)

        call random_number(q1_y(n1s:n1e, n2s:n2e, n3s:n3e))
        call random_number(q2_y(n1s:n1e, n2s:n2e, n3s:n3e))
        call random_number(q3_y(n1s:n1e, n2s:n2e, n3s:n3e))

        v1m=0.d0
        v2m=0.d0
        v3m=0.d0

        do j=1,n2-1

            yr=abs(Yc(j)-L2/2.d0)
            modulation_j=disturbance_intensity*dexp(-0.2d0*yr**2)

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    !   random disturbance  on u, v and w
                    q1_y(i,j,k)=q1_y(i,j,k)*modulation_j
                    q2_y(i,j,k)=q2_y(i,j,k)*modulation_j
                    q3_y(i,j,k)=q3_y(i,j,k)*modulation_j

                    v1m(j)=v1m(j)+q1_y(i,j,k)
                    v2m(j)=v2m(j)+q2_y(i,j,k)
                    v3m(j)=v3m(j)+q3_y(i,j,k)


                enddo
            enddo

            call MPI_ALLREDUCE (v1m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v1m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v2m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v2m(j)=glob_value/dfloat(n1m*n3m)

            call MPI_ALLREDUCE (v3m(j), glob_value, 1, MPI_DOUBLE_PRECISION , MPI_SUM , MPI_COMM_WORLD , mpi_err)
            v3m(j)=glob_value/dfloat(n1m*n3m)

        enddo


        ts1=0.d0
        ts3=0.d0

        if (flow_type==CONSTANT_FLOW) then
            if (streamwise==1)  ts1=uref
            if (streamwise==3)  ts3=uref
        end if

        if (flow_type==CHANNEL_FLOW) then
            if (streamwise==1) call perform_stream1(ts1, BC2, BC3)
            if (streamwise==3) call perform_stream3(ts3, BC1, BC2)
        end if

        if (flow_type==FLOW_FROM_INFLOW) then
            call get_inflow(ts1)
        end if

        do j=1,n2

            do k=ystart(3), yend(3)
                do i=ystart(1), yend(1)

                    q3_y(i,j,k)=q3_y(i,j,k)-v3m(j) + ts3(i,j)
                    q2_y(i,j,k)=q2_y(i,j,k)-v2m(j)
                    q1_y(i,j,k)=q1_y(i,j,k)-v1m(j) + ts1(j,k)        ! Poiseuille + disturbance

                enddo
            enddo
        enddo

        ! CLEAN FIELDS ***************************************************************
        if (yend(1)==n1) then
            do k = ystart(3), yend(3)
                do j = 1, n2
                    q1_y(n1,j,k)=0.d0
                    q2_y(n1,j,k)=0.d0
                    q3_y(n1,j,k)=0.d0
                    !if ((BC1==OPEN2).or.(BC1==UNBOUNDED).or.(BC1==UNBOUNDED)
                end do
            end do
        end if

        if (yend(3)==n3) then
            do j = 1, n2
                do i = ystart(1), yend(1)
                    q1_y(i,j,n3)=0.d0
                    q2_y(i,j,n3)=0.d0
                    q3_y(i,j,n3)=0.d0
                end do
            end do
        end if

        do k = ystart(3), yend(3)
            do i = ystart(1), yend(1)
                q1_y(i,n2,k)=0.d0
                q2_y(i,n2,k)=0.d0
                q3_y(i,n2,k)=0.d0
            end do
        end do

        call transpose_y_to_x(q3_y, q3_x)
        call transpose_y_to_z(q3_y, q3_z)

        call transpose_y_to_x(q1_y, q1_x)
        call transpose_y_to_z(q1_y, q1_z)

        call transpose_y_to_x(q2_y, q2_x)
        call transpose_y_to_z(q2_y, q2_z)

        call MPI_BARRIER(MPI_COMM_WORLD , mpi_err)

        !Impermeability conditions ********************************************************

        ! X1 direction
        if ((BC1==FREESLIP).or.(BC1==NOSLIP)) then

            q3_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q2_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_wall10(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_x(1, xstart(2):xend(2), xstart(3):xend(3))   =0.d0

            q3_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q2_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_wall11(xstart(2):xend(2), xstart(3):xend(3)) =0.d0
            q1_x(n1, xstart(2):xend(2), xstart(3):xend(3))  =0.d0

        end if

        ! X2 direction
        if ((BC2==FREESLIP).or.(BC2==NOSLIP)) then

            q3_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q1_wall20(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_y(ystart(1):yend(1), 1, ystart(3):yend(3))   =0.d0

            q3_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q1_wall21(ystart(1):yend(1), ystart(3):yend(3)) =0.d0
            q2_y(ystart(1):yend(1), n2, ystart(3):yend(3))  =0.d0

        end if

        ! ATTENTION
        ! X3 direction
        if ((BC3==FREESLIP).or.(BC3==NOSLIP)) then

            q3_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q2_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q1_wall30(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q3_z(zstart(1):zend(1), zstart(2):zend(2), 1) =0.d0

            q3_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q2_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q1_wall31(zstart(1):zend(1), zstart(2):zend(2))=0.d0
            q3_z(zstart(1):zend(1), zstart(2):zend(2), n3) =0.d0

        end if

        ! ATTENTION
        if ((BC1==OPEN).or.(BC1==OPEN2)) then

            call random_number(q2_wall10(xstart(2):xend(2), xstart(3):xend(3)))
            call random_number(q3_wall10(xstart(2):xend(2), xstart(3):xend(3)))

            do k=xstart(3), xend(3)
                do j=xstart(2), min(xend(2),n2-1)

                    yr=abs(Yc(j)-L2/2.d0)
                    modulation_j=disturbance_intensity*dexp(-0.2d0*yr**2)

                    if (inflow_mode==INFLOW_SQUARE) then

                        if ((k.ge.inflow_sq_k1).and.(k.lt.inflow_sq_k2).and.(j.ge.inflow_sq_j1).and.(j.lt.inflow_sq_j2)) then
                            q1_wall10(j, k)=inflow_int
                            q1_x(1,j,k)=q1_wall10(j, k)
                            q2_wall10(j, k)=0.d0
                            q3_wall10(j, k)=0.d0
                        else
                            q1_wall10(j, k)=q1_x(1,j,k)
                            q2_wall10(j, k)=q2_wall10(j, k)*modulation_j
                            q3_wall10(j, k)=q3_wall10(j, k)*modulation_j
                        endif

                    endif

                    if (inflow_mode==INFLOW_NONE) then

                        q1_wall10(j, k)=q1_x(1,j,k)
                        q2_wall10(j, k)=q2_wall10(j, k)*modulation_j
                        q3_wall10(j, k)=q3_wall10(j, k)*modulation_j

                    endif

                    q3_wall11(j, k) = q3_x(n1-1, j, k)
                    q2_wall11(j, k) = q2_x(n1-1, j, k)
                    q1_wall11(j, k) = q1_x(n1-1, j, k)
                    q1_x(n1, j, k)  = q1_wall11(j, k)

                enddo
            enddo

        end if

        call create_snapshot(snapshot_path, "INITIALIZATION", q1_y, "W", 2)
        call create_snapshot(snapshot_path, "INITIALIZATION", q2_y, "V", 2)
        call create_snapshot(snapshot_path, "INITIALIZATION", q3_y, "U", 2)

        return


    contains
        subroutine perform_stream1(stream1, BC2, BC3)
            implicit none

            real*8, dimension(ystart(2):yend(2), ystart(3):yend(3)) :: stream1
            integer                                                 :: BC2, BC3

            real*8                                                  :: f2(n2), f3(n3), c2, c3
            integer                                                 :: j, k

            f3=1.d0

            if (BC2==NOSLIP) then


                if (mod(n2, 2)==0) then
                    c2=Yc(n2/2)
                else
                    c2=Y((n2-1)/2+1)
                end if

                do j=1,n2-1
                    f2(j)=(1.d0-((Yc(j)-c2)/(0.5d0*L2))**2)
                enddo
                f2(n2)=f2(n2-1)

                if (BC3==NOSLIP) then

                    do k=1,n3

                        if (mod(n3, 2)==0) then
                            c3=(n3/2-0.5d0)*dx3
                        else
                            c3=((n3-1)/2+1-0.5d0)*dx3
                        end if

                        f3(k)=(1.d0-(((k-0.5d0)*dx3-c3)/(0.5d0*L3))**2)

                    enddo

                end if

                do k = ystart(3),yend(3)
                    do j= ystart(2),yend(2)
                        stream1(j,k)=f2(j)*f3(k)
                    end do
                end do

            else
                stream1=0.d0
            end if

        end subroutine perform_stream1


        subroutine perform_stream3(stream3, BC1, BC2)
            implicit none

            real*8, dimension(ystart(1):yend(1), ystart(2):yend(2)) :: stream3
            integer                                                 :: BC1, BC2

            real*8                                                  :: f1(n1), f2(n2), c1, c2
            integer                                                 :: i, j

            f1=1.d0

            if (BC2==NOSLIP) then


                do j=1,n2

                    if (mod(n2, 2)==0) then
                        c2=Yc(n2/2)
                    else
                        c2=Y((n2-1)/2+1)
                    end if

                    f2(j)=(1.d0-((Yc(j)-c2)/(0.5d0*L2))**2)

                enddo

                if (BC1==NOSLIP) then

                    if (mod(n1, 2)==0) then
                        ! Zc=(i-0.5)*dx1
                        c1=(n1/2-0.5d0)*dx1
                    else
                        c1=((n1-1)/2+1-0.5d0)*dx1
                    end if

                    do i=1,n1
                        f1(i)=(1.d0-(((i-0.5d0)*dx1-c1)/(0.5d0*L1))**2)
                    enddo

                end if

                do j = ystart(2),yend(2)
                    do i= ystart(1),yend(1)
                        stream3(i,j)=f1(i)*f2(j)
                    end do
                end do

            else
                stream3=0.d0
            end if

        end subroutine perform_stream3

        subroutine get_inflow(ts11, ntime)
            use HDF5_IO

            implicit none
            integer, optional   :: ntime
            integer, save   :: inflow_nb=1
            character(200)       :: current_inflow_path

            real*8, dimension(1, ystart(2):yend(2), ystart(3):yend(3))      :: ts11_tmp, ts12_tmp, ts13_tmp
            real*8, dimension(ystart(2):yend(2), ystart(3):yend(3))         :: ts11, ts12, ts13

            character*10 tmp_str

            write(tmp_str, "(i10)")inflow_nb+inflow_start-1
            current_inflow_path=trim(inflow_path)//'outflow_'//trim(adjustl(tmp_str))

            if (nrank==0) write(*,*)
            if (nrank==0) write(*,*) "Reading inflow from file:", trim(current_inflow_path)//".h5"

            call hdf_read_3Dfield(current_inflow_path, ts11_tmp, "q1_out", 1, ny_global, nz_global, 1,1, ystart(2),yend(2), ystart(3),yend(3))
            !call hdf_read_3Dfield(current_inflow_path, ts12_tmp, "q2_out", 1, ny_global, nz_global, 1,1, xstart(2),xend(2), xstart(3),xend(3))
            !call hdf_read_3Dfield(current_inflow_path, ts13_tmp, "q3_out", 1, ny_global, nz_global, 1,1, xstart(2),xend(2), xstart(3),xend(3))

            ts11(:,:)=ts11_tmp(1, :,:)
            !ts12(:,:)=ts12_tmp(1, :,:)
            !ts13(:,:)=ts13_tmp(1, :,:)

        end subroutine get_inflow

    end subroutine


end module Turbulene_generator
